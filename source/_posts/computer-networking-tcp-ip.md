---
title: 计算机网络：深入理解TCP/IP协议栈
date: 2025-12-26 15:00
categories:
  - 计算机网络
  - 网络协议
tags:
  - TCP/IP
  - 网络编程
  - 协议栈
  - Socket
---

# 计算机网络：深入理解TCP/IP协议栈

TCP/IP协议栈是现代互联网的基石，理解它对于网络编程和系统设计至关重要。本文将全面解析TCP/IP协议栈的各个层次。

## TCP/IP模型概览

TCP/IP模型分为四层，从下到上依次为：

```
┌─────────────────────────────────┐
│   应用层 (Application Layer)     │  HTTP, FTP, SMTP, DNS...
├─────────────────────────────────┤
│   传输层 (Transport Layer)       │  TCP, UDP
├─────────────────────────────────┤
│   网络层 (Internet Layer)        │  IP, ICMP, IGMP
├─────────────────────────────────┤
│   链路层 (Link Layer)            │  Ethernet, Wi-Fi
└─────────────────────────────────┘
```

## 链路层（Link Layer）

链路层负责在直连的两个节点间传输数据帧。

### 以太网帧结构

```
+----------+----------+--------------+------+----------+
| 目标MAC  | 源MAC    | 以太网类型   | 数据 | FCS      |
| 6字节    | 6字节    | 2字节        |      | 4字节    |
+----------+----------+--------------+------+----------+
```

### MAC地址

MAC地址是48位的物理地址，格式如：`00:1A:2B:3C:4D:5E`

- 前24位：厂商识别码（OUI）
- 后24位：厂商分配的序列号

### ARP协议

ARP（地址解析协议）用于将IP地址解析为MAC地址：

```
1. 主机A广播："谁是192.168.1.1？请告诉192.168.1.100"
2. 主机B响应："我是192.168.1.1，我的MAC是AA:BB:CC:DD:EE:FF"
```

## 网络层（Internet Layer）

网络层负责数据包的路由和转发。

### IP协议

IP数据报头部结构（IPv4）：

```
 0               16                             31
 +----------------+-----------------------------+
 |版本|头长度|   服务类型   |       总长度         |
 +-------+-------+-------------+-----------------+
 |       标识符        |标志|  片偏移           |
 +---------------------+----------+--------------+
 |  TTL  |  协议  |      头部校验和            |
 +-------+-------+-----------------------------+
 |                  源IP地址                   |
 |                                               |
 +---------------------+-------------------------+
 |                目标IP地址                    |
 |                                               |
 +---------------------+-------------------------+
```

### ICMP协议

ICMP用于网络诊断，ping命令就使用了ICMP：

```bash
$ ping google.com
PING google.com (142.250.185.46): 56 data bytes
64 bytes from 142.250.185.46: icmp_seq=0 ttl=117 time=14.2 ms
```

### 路由选择

路由器根据路由表决定数据包的转发路径：

```
目标网络          子网掩码           网关
192.168.1.0     255.255.255.0     0.0.0.0
0.0.0.0         0.0.0.0           192.168.1.1
```

## 传输层（Transport Layer）

传输层提供端到端的通信服务。

### TCP协议

TCP是可靠的、面向连接的传输协议。

#### TCP头部结构

```
 0               16                              31
 +--------------------------+--------------------+
 |      源端口号             |    目标端口号      |
 +--------------------------+--------------------+
 |                    序列号                      |
 +------------------------------------------------+
 |                    确认号                      |
 +------+-----+-----+------+--------------------+
 |头长度| 保留 |标志 |  窗口大小              |
 +------+-----+-----+--------------------------+
 |        校验和          |      紧急指针        |
 +--------------------------+--------------------+
```

#### TCP三次握手

```
客户端                                    服务器
   |                                       |
   |         SYN, seq=x                    |
   |-------------------------------------->|
   |                                       |
   |    SYN+ACK, seq=y, ack=x+1            |
   |<--------------------------------------|
   |                                       |
   |    ACK, seq=x+1, ack=y+1              |
   |-------------------------------------->|
   |                                       |
   |           连接建立                      |
```

为什么需要三次握手？
- 防止失效的连接报文段突然又传送到服务端
- 同步双方的初始序列号

#### TCP四次挥手

```
客户端                                    服务器
   |                                       |
   |            FIN, seq=u                 |
   |-------------------------------------->|
   |         ACK, seq=v, ack=u+1           |
   |<--------------------------------------|
   |                                       |
   |         FIN, seq=w, ack=u+1           |
   |<--------------------------------------|
   |    ACK, seq=u+1, ack=w+1              |
   |-------------------------------------->|
   |                                       |
   |           连接关闭                      |
```

#### TCP流量控制

使用**滑动窗口**机制实现流量控制：

```
发送窗口：
[已确认] [已发送未确认] [可发送] [不可发送]
  |----------|----------|-----------|
    1字节      3字节        4字节
```

### UDP协议

UDP是无连接的、不可靠的传输协议，但效率高。

#### UDP头部结构

```
 0               16                              31
 +--------------------------+--------------------+
 |      源端口号             |    目标端口号      |
 +--------------------------+--------------------+
 |        长度              |      校验和        |
 +--------------------------+--------------------+
```

#### TCP vs UDP

| 特性 | TCP | UDP |
|------|-----|-----|
| 连接性 | 面向连接 | 无连接 |
| 可靠性 | 可靠传输 | 不可靠 |
| 效率 | 较低（头部开销大） | 高 |
| 适用场景 | 文件传输、邮件 | 视频流、游戏 |

## 应用层（Application Layer）

应用层直接为用户的应用程序提供服务。

### HTTP协议

HTTP请求格式：

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html

```

HTTP响应格式：

```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234

<html>
<body>
<h1>Hello, World!</h1>
</body>
</html>
```

### DNS协议

DNS将域名解析为IP地址：

```
查询过程：
1. 客户端 -> 本地DNS服务器："www.google.com的IP？"
2. 本地DNS -> 根域名服务器：".的DNS服务器IP？"
3. 本地DNS -> 顶级域名服务器：".com的DNS服务器IP？"
4. 本地DNS -> 权威域名服务器："google.com的DNS服务器IP？"
5. 本地DNS -> 客户端：返回解析结果
```

## Socket编程

Socket是网络编程的基础API。

### TCP服务器示例（Python）

```python
import socket

# 创建socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 绑定地址和端口
server_socket.bind(('0.0.0.0', 8080))

# 监听连接
server_socket.listen(5)

while True:
    # 接受连接
    client_socket, address = server_socket.accept()
    print(f"Connection from {address}")

    # 接收数据
    data = client_socket.recv(1024)
    print(f"Received: {data.decode()}")

    # 发送响应
    client_socket.send(b"Hello, Client!")

    # 关闭连接
    client_socket.close()
```

### TCP客户端示例（Python）

```python
import socket

# 创建socket
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 连接服务器
client_socket.connect(('127.0.0.1', 8080))

# 发送数据
client_socket.send(b"Hello, Server!")

# 接收响应
data = client_socket.recv(1024)
print(f"Received: {data.decode()}")

# 关闭连接
client_socket.close()
```

## 性能优化

### TCP优化

1. **启用Nagle算法**：减少小包发送
2. **调整TCP窗口大小**：提高吞吐量
3. **启用TCP Fast Open**：减少连接延迟

```bash
# sysctl配置示例
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216
```

### 网络性能监控

```bash
# 查看网络连接
netstat -ant

# 测试网络延迟
ping -c 4 google.com

# 测试带宽
iperf -s  # 服务器端
iperf -c <server_ip>  # 客户端
```

## 常见问题

### TIME_WAIT状态

大量TIME_WAIT连接会占用系统资源：

```bash
# 查看TIME_WAIT连接
netstat -ant | grep TIME_WAIT | wc -l

# 快速复用TIME_WAIT socket
echo "1" > /proc/sys/net/ipv4/tcp_tw_reuse
```

### 连接队列溢出

```bash
# 增加连接队列
echo "1024" > /proc/sys/net/core/somaxconn
```

## 总结

TCP/IP协议栈是分层设计的：
- 链路层：负责物理传输
- 网络层：负责路由寻址
- 传输层：提供端到端服务
- 应用层：面向用户应用

理解每一层的作用和协议，对于网络编程和系统开发至关重要。
